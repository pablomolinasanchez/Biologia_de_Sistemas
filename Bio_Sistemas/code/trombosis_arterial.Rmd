---
title: "Análisis con iGraph de los genes involucrados en la Trombosis Arterial"
author: "Pablo Molina Sánchez y Hugo Ávalos de Rorthais"
date: "`r format(Sys.time(), '%A %d, %B %Y. %H.%M.%S')`"
output: 
  html_document:
    toc: yes
    toc_float: yes
    fig_caption: yes
    number_sections: yes
    theme: journal
    df_print: paged
  pdf_document:
    toc: yes
    fig_caption: yes
    df_print: kable
---
# Librerías y Path{.tabset}
## Librerías
```{r, warning=FALSE,message=FALSE}
library(DOSE)
library(clusterProfiler)
library(org.Hs.eg.db)
library(devtools)
library(dplyr)
library(igraph)
library(ggplot2)
library(zoo)
```
##Path
```{r}
path<-"~Biologia_de_Sistemas/Bio_Sistemas/code/" #select your path
setwd(path)
```
# Creación del grafo{.tabset}
```{r}
library(igraph)
nodes<-read.csv("string_node_degrees.tsv",sep ="")
links<-read.csv("string_interactions.tsv",sep="")
net <- graph_from_data_frame(d=links,vertices=nodes, directed=T)
```
## Genes involucrados y sus iteracciones
```{r}
V(net)$size<-V(net)$node_degree
plot(net,layout=layout_nicely, edge.arrow.size=0.2, edge.curved=0.1, vertex.frame.color="black",vertex.label=V(net)$id, vertex.label.color="black", vertex.label.cex=0.7)
```
## ¿Cuál es su matriz de adyacencia?
```{r}
adjacency_matrix <- as_adj(net)
adjacency_matrix
```
## ¿Es un grafo simétrico?
```{r}
isSymmetric(as.matrix(adjacency_matrix))
```
## ¿Es un grafo pesado?
```{r}
is.weighted(net)
```
## ¿Están todos los genes interaccionando entre sí?
```{r}
is.connected(net)
```

## ¿Cuál es la distancia media entre los genes?
```{r}
mean_distance(net, directed=F)
```
Es un valor bastante bajo, por lo que podemos determinar que está altamente conectado

## ¿Cuál es el gen con más grado y, por tanto, con más conexiones y más relevante para la trombosis arterial?
```{r}
degreeMax<-max(V(net)$node_degree)
V(net)$name[V(net)$node_degree==degreeMax]
```

Vemos que el IL10 es el gen con más grado y por tanto más importante

## ¿Con qué gen guarda mayor relación IL10?
```{r}
news.path <- shortest_paths(net, from = V(net), to  = 'IL10',output = "both")
ecol <- rep("gray0", ecount(net))
ecol[unlist(news.path$epath)] <- "orange"
ew <- rep(2, ecount(net))
ew[unlist(news.path$epath)] <- 4
vcol <- rep("gray40", vcount(net))
vcol[unlist(news.path$vpath)] <- "gold"
plot(net,layout=layout_nicely, vertex.color=vcol, edge.color=ecol, edge.width=ew, edge.arrow.mode=0)
```
El gen que guarda mayor relación con IL10 es AKT1


## ¿Es libre de escala?
```{r}
scale_freeness<-function(net){
  d <- degree(net, mode="in")
  fit1 <- fit_power_law(d, 1,implementation = 'plfit')
  if(fit1$alpha<=3 && fit1$alpha>=2){
    return("Es libre de escala")
  }else{
    return("No es libre de escala")
  }
}
scale_freeness(net)
```


# Network Propagation

Creamos un txt solo con el nombre de los genes a partir del .tsv con informacion de los nodos.

```{r}
head(nodes)
```

```{r}
genIDs <- nodes$X.node
genIDs
```
```{r warning=FALSE}
genes <- bitr(genIDs, fromType = "SYMBOL", toType = "ENTREZID", OrgDb = org.Hs.eg.db)
write.table(genes$ENTREZID, file = "genesIDs.txt", quote = FALSE, row.names = FALSE )
```
Ahora con el siguiente comando ejecuamos DIAMOnD:

python3 DIAMOnD.py network_diamond.txt genesIDs.txt 50 1 outputDiamond.txt

Leemos el archivo y creamos un nuevo dataset con la propagación:
```{r}
genesProp<-read.csv("outputDiamond.txt",sep="\t")
genesProp<-genesProp$DIAMOnD_node
```
```{r}
genesProp_Name<-genes <- bitr(genesProp, fromType = "ENTREZID", toType = "SYMBOL", OrgDb = org.Hs.eg.db)
genesName<-c(genesProp_Name$SYMBOL,genIDs)
genesIds_prop<-c(genesProp_Name$ENTREZID,genes$ENTREZID)
genesName
```

Con esto obtenemos el listado de genes propagados junto a los pertenecientes a la trombosis arterial. Creamos un nuevo gráfico tras descargar nuesvos archivos de STRINGDB.
```{r}
nodes_prop<-read.csv("string_node_degrees_prop.tsv",sep ="")
links_prop<-read.csv("string_interactions_prop.tsv",sep="")
net_prop <- graph_from_data_frame(d=links_prop,vertices=nodes_prop, directed=T)

```
```{r}
community <- cluster_edge_betweenness(net_prop)
dendPlot(community, mode="hclust")
plot(community, net_prop,layout=layout_nicely ,edge.arrow.size=0.2, edge.curved=0.1, vertex.frame.color="black",vertex.label=V(net_prop)$id, vertex.label.color="black", vertex.label.cex=0.7)
length(community)
hist(membership(community))
```



# Enriquecimientos de las comunidades{.tabset}
## Función para el enriquecimiento de los procesos biológicos con GO
```{r}
data(geneList, package="DOSE")
overrep_enrichment_GO <- function(gene,universe,Db, ont, pAdjustMethod, p,q) {
  ego <- enrichGO(gene          = gene,
                  universe      = universe,
                  OrgDb         = Db,
                  ont           = ont,
                  pAdjustMethod = pAdjustMethod,
                  pvalueCutoff  = p,
                  qvalueCutoff  = q,
                  readable      = TRUE)
  return (ego)
}

```
## Comunidad 1 
```{r}

community_1<-as.data.frame(community[1])
community[1]
community_1<-bitr(community[1]$`1`, fromType ="SYMBOL", toType ="ENTREZID",OrgDb=org.Hs.eg.db)
go_1<-overrep_enrichment_GO(community_1$ENTREZID,geneList,org.Hs.eg.db,"BP","BH",0.05,0.05)
head(go_1)
```
## Comunidad 2 
```{r}
community_2<-as.data.frame(community[2])
community[2]
community_2<-bitr(community_2$X2, fromType = "SYMBOL", toType = "ENTREZID", OrgDb = org.Hs.eg.db)
go_2<-overrep_enrichment_GO(community_2$ENTREZID,geneList,org.Hs.eg.db,"BP","BH", 0.05,0.05)
head(go_2)
```
## Comunidad 3 
```{r}
community_3<-as.data.frame(community[3])
community_3
community_3<-bitr(community[3]$`3`, fromType = "SYMBOL", toType = "ENTREZID", OrgDb = org.Hs.eg.db)
go_3<-overrep_enrichment_GO(community_3$ENTREZID,geneList,org.Hs.eg.db,"BP","BH", 0.05,0.05)
head(go_3)
```
## Comunidad 4 (un gen)
```{r}
community_4<-as.data.frame(community[4])
community_4
community_4<-bitr(community[4]$`4`, fromType = "SYMBOL", toType = "ENTREZID", OrgDb = org.Hs.eg.db)
go_4<-overrep_enrichment_GO(community_4$ENTREZID,geneList,org.Hs.eg.db,"BP","BH", 0.05,0.05)
head(go_4)
```
## Comunidad 5 (un gen)
```{r}
community_5<-as.data.frame(community[5])
community_5
community_5<-bitr(community[5]$`5`, fromType = "SYMBOL", toType = "ENTREZID", OrgDb = org.Hs.eg.db)
go_5<-overrep_enrichment_GO(community_5$ENTREZID,geneList,org.Hs.eg.db,"BP","BH", 0.05,0.05)
head(go_5)
```
## Comunidad 6 (un gen) 
```{r}
community_6<-as.data.frame(community[6])
community_6
community_6<-bitr(community[6]$`6`, fromType = "SYMBOL", toType = "ENTREZID", OrgDb = org.Hs.eg.db)
go_6<-overrep_enrichment_GO(community_6$ENTREZID,geneList,org.Hs.eg.db,"BP","BH", 0.05,0.05)
head(go_6)
```
## Comunidad 7 
```{r}
community_7<-as.data.frame(community[7])
community_7
community_7<-bitr(community[7]$`7`, fromType = "SYMBOL", toType = "ENTREZID", OrgDb = org.Hs.eg.db)
go_7<-overrep_enrichment_GO(community_7$ENTREZID,geneList,org.Hs.eg.db,"BP","BH", 0.05,0.05)
head(go_7)
```
## Comunidad 8 (un gen)
```{r}
community_8<-as.data.frame(community[8])
community_8
community_8<-bitr(community[8]$`8`, fromType = "SYMBOL", toType = "ENTREZID", OrgDb = org.Hs.eg.db)
go_8<-overrep_enrichment_GO(community_8$ENTREZID,geneList,org.Hs.eg.db,"BP","BH", 0.05,0.05)
head(go_8)
```
## Comunidad 9 (un gen) 
```{r}
community_9<-as.data.frame(community[9])
community_9
community_9<-bitr(community[9]$`9`, fromType = "SYMBOL", toType = "ENTREZID", OrgDb = org.Hs.eg.db)
go_9<-overrep_enrichment_GO(community_9$ENTREZID,geneList,org.Hs.eg.db,"BP","BH", 0.05,0.05)
head(go_9)
```
## Comunidad 10 
```{r}
community_10<-as.data.frame(community[10])
community_10
community_10<-bitr(community[10]$`10`, fromType = "SYMBOL", toType = "ENTREZID", OrgDb = org.Hs.eg.db)
go_10<-overrep_enrichment_GO(community_10$ENTREZID,geneList,org.Hs.eg.db,"BP","BH", 0.05,0.05)
head(go_10)
```

# Estudio de la robustez {.tabset}
## Función
```{r message=FALSE, warning=FALSE, include=FALSE}
# definimos las funciones:
# ataque dirigido:
sequential.attacks.targeted <- function(grafo, measure=degree){
  
  q = seq(from=0,to=1,by=0.01)
  g = grafo
  S = max(components(grafo)$csize)/vcount(grafo)
  contador = S
  removalset = NULL
  v = vcount(grafo)
  s = max(components(grafo)$csize)
  for(i in q){
    if(max(components(g)$csize)/vcount(grafo) >0.05){
      removalset <- names(sort(degree(g),decreasing = T)[1:(i*vcount(g))])
      g <- delete.vertices(graph = g, v = removalset)
      S = c(S, max(components(g)$csize)/vcount(grafo))
      v <- c(v, vcount(g))
      s = c(s, max(components(g)$csize))
      contador = max(components(g)$csize)/vcount(grafo)
    }
    
  }
  S.vs.q <- tbl_df(data.frame(cbind(q[1:length(S)],S,s,v)))
  names(S.vs.q) <- c("q", "S", "s", "v")
  return(S.vs.q)
}
# ataque aleatorio
sequential.attacks.random <- function(grafo, measure=degree){
  
  q = seq(from=0,to=1,by=0.01)
  g = grafo
  S = max(components(grafo)$csize)/vcount(grafo)
  contador = S
  removalset = NULL
  v = vcount(grafo)
  s = max(components(grafo)$csize)
  for(i in q){
    if(contador > 0.05 & length(removalset) < vcount(g)/2){
      removalset <- sample(x = V(g)$name, size = 1, replace = F)
      g <- delete.vertices(graph = g, v = removalset)
      S = c(S, max(components(g)$csize)/vcount(grafo))
      v <- c(v, vcount(g))
      s = c(s, max(components(g)$csize))
      contador = max(components(g)$csize)/vcount(grafo)
    }
    
  }
  S.vs.q <- tbl_df(data.frame(cbind(q[1:length(S)],S,s,v)))
  names(S.vs.q) <- c("q", "S", "s", "v")
  return(S.vs.q)
}
#puntuacion robustez dirigido
robustness.targeted2 <- function(grafo, measure=degree){
  
  
  
  q = seq(from=0.01,to=1,by=0.01)
  g = grafo
  S = max(components(grafo)$csize)/vcount(grafo)
  contador = S
  removalset = NULL
  for(i in q){
    if(max(components(g)$csize)/vcount(grafo) >0.05){
      removalset <- names(sort(degree(g),decreasing = T)[1:(i*vcount(g))])
      g <- delete.vertices(graph = g, v = removalset)
      S = c(S, max(components(g)$csize)/vcount(grafo))
      contador = max(components(g)$csize)/vcount(grafo)
    }
  }
  x <- as.numeric(q[1:length(S)])
  y <- as.numeric(S)
  id <- order(x)
  return(sum(diff(x[id])*rollmean(y[id],2)))
} 
#puntuacionrobustez aleatorio
robustness.random2 <- function(grafo, measure=degree){
 
  q = seq(from=0.01,to=1,by=0.01)
  g = grafo
  S = max(components(grafo)$csize)/vcount(grafo)
  contador = S
  removalset = NULL
  for(i in q){
    if(contador > 0.05 & length(removalset) < vcount(g)/2){
      removalset <- sample(x = V(g)$name, size = 10, replace = F)
      g <- delete.vertices(graph = g, v = removalset)
      S = c(S, max(components(g)$csize)/vcount(grafo))
      
      contador = max(components(g)$csize)/vcount(grafo)
    }
  }
  x <- as.numeric(q[1:length(S)])
  x <- x[!is.na(x)]
  y <- as.numeric(S)
  id <- order(x)
  return(sum(diff(x[id])*rollmean(y[id],2)))
} 
# plot the graph
plot_graph <- function(graph){
  V(graph)$label <- NA
  V(graph)$name <- NA
  V(graph)$size <- degree(graph)/5
  E(graph)$edge.color <- "gray80"
  V(graph)$color <- "tomato"
  # graph_attr(graph, "layout") <- layout_with_lgl
  graph_attr(graph, "layout") <- layout.kamada.kawai
  plot(graph)
  
}
# plot
plot_graph <- function(graph){
  V(graph)$label <- NA
  V(graph)$name <- NA
  V(graph)$size <- degree(graph)/5
  E(graph)$edge.color <- "gray80"
  V(graph)$color <- "tomato"
  # graph_attr(graph, "layout") <- layout_with_lgl
  graph_attr(graph, "layout") <- layout.kamada.kawai
  plot(graph)
  
}
```

## Ataque dirigido

```{r echo=FALSE, warning=FALSE}
targeted <- sequential.attacks.targeted(net_prop, measure = degree)
targeted$attack <- rep("targeted")
```

```{r echo=FALSE, warning=FALSE}
ggplot(targeted, aes(x=q, y=S, color=S)) + geom_point(alpha=.4, size=2) +
  theme_bw() +
  theme(plot.background = element_blank(),  panel.grid.minor = element_blank(),plot.title=element_text(size=15)) +
  geom_line() +
  ggtitle("Ataque secuencial dirigido") +
  ylab("S(q)") +
  xlab("q")
```

```{r}
targeted_score <- robustness.targeted2(net_prop, measure = degree)
targeted_score
```
```{r}
targeted
targeted[targeted$q == '0.1', ]
```


## Ataque aleatorio

```{r warning=FALSE}
random <- sequential.attacks.random(net_prop, measure = degree)
random$attack <- rep("random")
```


```{r warning=FALSE}
ggplot(random, aes(x=q, y=S, color=S)) + geom_point(alpha=.4, size=2) +
  theme_bw() +
  theme(plot.background = element_blank(),  panel.grid.minor = element_blank(),plot.title=element_text(size=15)) +
  geom_line() +
  ggtitle("Ataque secuencial aleatorio") +
  ylab("S(q)") +
  xlab("q")
```

```{r}
random_score <- robustness.random2(net_prop, measure = degree)
random_score
```

## Nodos importantes
```{r}
#calculamos el numero de enlaces que salen de cada vertice
net_degree <- degree(net_prop, mode = c("out"))
(net_degree)
```
```{r}
hist(net_degree, breaks = 20)
```
```{r}
#el nodo con mas enlaces
net_degree[which.max(net_degree)]
```

```{r}
net_betweenness <- betweenness(net_prop, directed = TRUE)
```

```{r}
#plot en el que el tamaño del nodo lo determina el numero de conexiones
plot(net_prop, 
     vertex.label = NA,
     edge.color = 'black',
     vertex.size = sqrt(net_betweenness),
     edge.arrow.size = 0.05,
     layout = layout_nicely(net_prop))
```
```{r}
#calculamos la densidad del grafo; que tan interconectada esta la red
gd <- edge_density(net_prop)
gd
```

```{r}
# promedio de las longitudes de los caminos más cortos entre todos los pares de nodos de la red. entre más pequeño el valor más interconectada la red
g.apl <- mean_distance(net_prop, directed = FALSE)
g.apl
```
```{r}
#plot interactivo por si luego queremos implemetnarlo

library(threejs)
g <- set_vertex_attr(net_prop, "color", value = "dodgerblue")
graphjs(g, vertex.size = 1)
```


```{r}
library(brainGraph)
#ataque dirigido con otra funcion
robustness(net_prop, type = "vertex", measure = 'degree' , N = 1000)
```
```{r}
m1 <- layout_nicely(net_prop)
plot(net_prop, vertex.label.color = "black", layout = m1 )

```

