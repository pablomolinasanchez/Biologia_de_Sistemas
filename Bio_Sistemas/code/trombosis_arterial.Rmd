---
title: "Análisis con iGraph de los genes involucrados en la Trombosis Arterial"
author: "Pablo Molina Sánchez y Hugo Ávalos de Rorthais"
date: "`r format(Sys.time(), '%A %d, %B %Y. %H.%M.%S')`"
output: 
  html_document:
    toc: yes
    toc_float: yes
    fig_caption: yes
    number_sections: yes
    theme: journal
    df_print: paged
  pdf_document:
    toc: yes
    fig_caption: yes
    df_print: kable
---
# Librerías y Path{.tabset}
## Librerías
```{r, warning=FALSE,message=FALSE}
library(DOSE)
library(clusterProfiler)
library(org.Hs.eg.db)
library(devtools)
library(dplyr)
library(igraph)
library(ggplot2)
library(zoo)
```
##Path
```{r}
path<-"~/Biologia_de_Sistemas/Bio_Sistemas/code/" #select your path
setwd(path)
```
# Creación del grafo{.tabset}
```{r}
library(igraph)
nodes<-read.csv("string_node_degrees.tsv",sep ="")
links<-read.csv("string_interactions.tsv",sep="")
net <- graph_from_data_frame(d=links,vertices=nodes, directed=T)
```
## Genes involucrados y sus iteracciones
```{r}
V(net)$size<-V(net)$node_degree
plot(net,layout=layout_nicely, edge.arrow.size=0.2, edge.curved=0.1, vertex.frame.color="black",vertex.label=V(net)$id, vertex.label.color="black", vertex.label.cex=0.7)
```
## ¿Cuál es su matriz de adyacencia?
```{r}
adjacency_matrix <- as_adj(net)
adjacency_matrix
```
## ¿Es un grafo simétrico?
```{r}
isSymmetric(as.matrix(adjacency_matrix))
```
## ¿Es un grafo pesado?
```{r}
is.weighted(net)
```
## ¿Están todos los genes interaccionando entre sí?
```{r}
is.connected(net)
```

## ¿Cuál es la distancia media entre los genes?
```{r}
mean_distance(net, directed=F)
```
Es un valor bastante bajo, por lo que podemos determinar que está altamente conectado

## ¿Cuál es el gen con más grado y, por tanto, con más conexiones y más relevante para la trombosis arterial?
```{r}
degreeMax<-max(V(net)$node_degree)
V(net)$name[V(net)$node_degree==degreeMax]
```

Vemos que el IL10 es el gen con más grado y por tanto más importante

## ¿Con qué gen guarda mayor relación IL10?
```{r}
news.path <- shortest_paths(net, from = V(net), to  = 'IL10',output = "both")
ecol <- rep("gray80", ecount(net))
ecol[unlist(news.path$epath)] <- "orange"
ew <- rep(2, ecount(net))
ew[unlist(news.path$epath)] <- 4
vcol <- rep("gray40", vcount(net))
vcol[unlist(news.path$vpath)] <- "gold"
plot(net,layout=layout_nicely, vertex.color=vcol, edge.color=ecol, edge.width=ew, edge.arrow.mode=0)
```
El gen que guarda mayor relación con IL10 es AKT1


## ¿Es libre de escala?
```{r}
scale_freeness<-function(net){
  d <- degree(net, mode="in")
  fit1 <- fit_power_law(d, 1,implementation = 'plfit')
  if(fit1$alpha<=3 && fit1$alpha>=2){
    return("Es libre de escala")
  }else{
    return("No es libre de escala")
  }
}
scale_freeness(net)
```
El grafo no es libre de escala, ya que, como hemos podido observar anteriormente, está altamente conectado entre sus nodos.

## ¿Qué comunidades presenta nuestro conjunto de genes?
Acontinuación, observamos las comunidades funcionales de genes que intervienen en la trombosis arterial.
```{r}
community <- cluster_edge_betweenness(net)
dendPlot(community, mode="hclust")
plot(community, net,layout=layout_nicely ,edge.arrow.size=0.2, edge.curved=0.1, vertex.frame.color="black",vertex.label=V(net)$id, vertex.label.color="black", vertex.label.cex=0.7)
length(community)
membership(community)
```
Como podemos ver, hay dos comunidades principales que engloban a gran mayoría de genes, una tercera que involucra a tres genes y oco comunidades restantes ocupadas por un gen cada una.

# Enriquecimientos de las comunidades{.tabset}
## Función para el enriquecimiento de los procesos biológicos con GO
```{r}
data(geneList, package="DOSE")
overrep_enrichment_GO <- function(gene,universe,Db, ont, pAdjustMethod, p,q) {
  ego <- enrichGO(gene          = gene,
                  universe      = universe,
                  OrgDb         = Db,
                  ont           = ont,
                  pAdjustMethod = pAdjustMethod,
                  pvalueCutoff  = p,
                  qvalueCutoff  = q,
                  readable      = TRUE)

  return (ego)
}
```

## Comunidad IL10, AKT1, IFNGR1, IL23R, PTEN,  PTPN22, STAT4, TP53  
```{r}
community_1<-community[1]

# introducimos sus ids
community_1_id<-list(3586,207,3459,149233,5728,26191,6775,7157)

go_1<-overrep_enrichment_GO(community_1_id,geneList,org.Hs.eg.db,"BP","BH", 0.05,0.05)
head(go_1)
```

## Comunidad CALR, JAK2, MPL, SH2B3, TET2, THPO
```{r}
community_3<-community[3]

# introducimos sus ids
community_3_id<-list(811,3717, 4352,10019,54790,7066)

go_3<-overrep_enrichment_GO(community_3_id,geneList,org.Hs.eg.db,"BP","BH", 0.05,0.05)
head(go_3)
```

# Estudio de la robustez
```{r message=FALSE, warning=FALSE, include=FALSE}
# definimos las funciones:

# ataque dirigido:
sequential.attacks.targeted <- function(grafo, measure=degree){
  
  q = seq(from=0,to=1,by=0.01)
  g = grafo
  S = max(components(grafo)$csize)/vcount(grafo)
  contador = S
  removalset = NULL
  v = vcount(grafo)
  s = max(components(grafo)$csize)
  for(i in q){
    if(max(components(g)$csize)/vcount(grafo) >0.05){
      removalset <- names(sort(degree(g),decreasing = T)[1:(i*vcount(g))])
      g <- delete.vertices(graph = g, v = removalset)
      S = c(S, max(components(g)$csize)/vcount(grafo))
      v <- c(v, vcount(g))
      s = c(s, max(components(g)$csize))
      contador = max(components(g)$csize)/vcount(grafo)
    }
    
  }
  S.vs.q <- tbl_df(data.frame(cbind(q[1:length(S)],S,s,v)))
  names(S.vs.q) <- c("q", "S", "s", "v")
  return(S.vs.q)
}

# ataque aleatorio
sequential.attacks.random <- function(grafo, measure=degree){
  
  q = seq(from=0,to=1,by=0.01)
  g = grafo
  S = max(components(grafo)$csize)/vcount(grafo)
  contador = S
  removalset = NULL
  v = vcount(grafo)
  s = max(components(grafo)$csize)
  for(i in q){
    if(contador > 0.05 & length(removalset) < vcount(g)/2){
      removalset <- sample(x = V(g)$name, size = 10, replace = F)
      g <- delete.vertices(graph = g, v = removalset)
      S = c(S, max(components(g)$csize)/vcount(grafo))
      v <- c(v, vcount(g))
      s = c(s, max(components(g)$csize))
      contador = max(components(g)$csize)/vcount(grafo)
    }
    
  }
  S.vs.q <- tbl_df(data.frame(cbind(q[1:length(S)],S,s,v)))
  names(S.vs.q) <- c("q", "S", "s", "v")
  return(S.vs.q)
}

#puntuacion robustez dirigido
robustness.targeted2 <- function(grafo, measure=degree){
  
  
  
  q = seq(from=0.01,to=1,by=0.01)
  g = grafo
  S = max(components(grafo)$csize)/vcount(grafo)
  contador = S
  removalset = NULL
  for(i in q){
    if(max(components(g)$csize)/vcount(grafo) >0.05){
      removalset <- names(sort(degree(g),decreasing = T)[1:(i*vcount(g))])
      g <- delete.vertices(graph = g, v = removalset)
      S = c(S, max(components(g)$csize)/vcount(grafo))
      contador = max(components(g)$csize)/vcount(grafo)
    }
  }
  x <- as.numeric(q[1:length(S)])
  y <- as.numeric(S)
  id <- order(x)
  return(sum(diff(x[id])*rollmean(y[id],2)))
} 
#puntuacionrobustez aleatorio

robustness.random2 <- function(grafo, measure=degree){
 
  q = seq(from=0.01,to=1,by=0.01)
  g = grafo
  S = max(components(grafo)$csize)/vcount(grafo)
  contador = S
  removalset = NULL
  for(i in q){
    if(contador > 0.05 & length(removalset) < vcount(g)/2){
      removalset <- sample(x = V(g)$name, size = 10, replace = F)
      g <- delete.vertices(graph = g, v = removalset)
      S = c(S, max(components(g)$csize)/vcount(grafo))
      
      contador = max(components(g)$csize)/vcount(grafo)
    }
  }
  x <- as.numeric(q[1:length(S)])
  x <- x[!is.na(x)]
  y <- as.numeric(S)
  id <- order(x)
  return(sum(diff(x[id])*rollmean(y[id],2)))
} 

# plot the graph
plot_graph <- function(graph){
  V(graph)$label <- NA
  V(graph)$name <- NA
  V(graph)$size <- degree(graph)/5
  E(graph)$edge.color <- "gray80"
  V(graph)$color <- "tomato"
  # graph_attr(graph, "layout") <- layout_with_lgl
  graph_attr(graph, "layout") <- layout.kamada.kawai
  plot(graph)
  
}
# plot
plot_graph <- function(graph){
  V(graph)$label <- NA
  V(graph)$name <- NA
  V(graph)$size <- degree(graph)/5
  E(graph)$edge.color <- "gray80"
  V(graph)$color <- "tomato"
  # graph_attr(graph, "layout") <- layout_with_lgl
  graph_attr(graph, "layout") <- layout.kamada.kawai
  plot(graph)
  
}
```

## Ataque dirigido

```{r echo=FALSE, warning=FALSE}
targeted <- sequential.attacks.targeted(net, measure = degree)
targeted$attack <- rep("targeted")
```

```{r echo=FALSE, warning=FALSE}
ggplot(targeted, aes(x=q, y=S, color=S)) + geom_point(alpha=.4, size=2) +
  theme_bw() +
  theme(plot.background = element_blank(),  panel.grid.minor = element_blank(),plot.title=element_text(size=15)) +
  geom_line() +
  ggtitle("Ataque secuencial dirigido") +
  ylab("S(q)") +
  xlab("q")
```

```{r}
targeted_score <- robustness.targeted2(net, measure = degree)
targeted_score
```


## Ataque aleatorio

```{r warning=FALSE}
random <- sequential.attacks.random(net, measure = degree)
random$attack <- rep("random")
```


```{r warning=FALSE}
ggplot(random, aes(x=q, y=S, color=S)) + geom_point(alpha=.4, size=2) +
  theme_bw() +
  theme(plot.background = element_blank(),  panel.grid.minor = element_blank(),plot.title=element_text(size=15)) +
  geom_line() +
  ggtitle("Ataque secuencial aleatorio") +
  ylab("S(q)") +
  xlab("q")
```

```{r}
random_score <- robustness.random2(net, measure = degree)
random_score
```

# Network Propagation

Creamos un txt solo con el nombre de los genes a partir del .tsv con informacion de los nodos.

```{r}
head(nodes)
```

```{r}
genIDs <- nodes$X.node
genIDs
```
```{r warning=FALSE}
genes <- bitr(genIDs, fromType = "SYMBOL", toType = "ENTREZID", OrgDb = org.Hs.eg.db)
write.table(genes$ENTREZID, file = "genesIDs.txt", quote = FALSE, row.names = FALSE )
```
Ahora con el siguiente comando ejecuamos DIAMOnD:

python3 DIAMOnD.py network_diamond.txt genesIDs.txt 100 1 outputDiamond.txt

# 
