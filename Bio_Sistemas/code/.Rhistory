robustness.random2 <- function(grafo, measure=degree){
q = seq(from=0.01,to=1,by=0.01)
g = grafo
S = max(components(grafo)$csize)/vcount(grafo)
contador = S
removalset = NULL
for(i in q){
if(contador > 0.05 & length(removalset) < vcount(g)/2){
removalset <- sample(x = V(g)$name, size = 10, replace = F)
g <- delete.vertices(graph = g, v = removalset)
S = c(S, max(components(g)$csize)/vcount(grafo))
contador = max(components(g)$csize)/vcount(grafo)
}
}
x <- as.numeric(q[1:length(S)])
x <- x[!is.na(x)]
y <- as.numeric(S)
id <- order(x)
return(sum(diff(x[id])*rollmean(y[id],2)))
}
# plot the graph
plot_graph <- function(graph){
V(graph)$label <- NA
V(graph)$name <- NA
V(graph)$size <- degree(graph)/5
E(graph)$edge.color <- "gray80"
V(graph)$color <- "tomato"
# graph_attr(graph, "layout") <- layout_with_lgl
graph_attr(graph, "layout") <- layout.kamada.kawai
plot(graph)
}
# plot
plot_graph <- function(graph){
V(graph)$label <- NA
V(graph)$name <- NA
V(graph)$size <- degree(graph)/5
E(graph)$edge.color <- "gray80"
V(graph)$color <- "tomato"
# graph_attr(graph, "layout") <- layout_with_lgl
graph_attr(graph, "layout") <- layout.kamada.kawai
plot(graph)
}
targeted <- sequential.attacks.targeted(net, measure = degree)
targeted$attack <- rep("targeted")
ggplot(targeted, aes(x=q, y=S, color=S)) + geom_point(alpha=.4, size=2) +
theme_bw() +
theme(plot.background = element_blank(),  panel.grid.minor = element_blank(),plot.title=element_text(size=15)) +
geom_line() +
ggtitle("Targeted sequential attacks") +
ylab("S(q)") +
xlab("q")
targeted_score <- robustness.targeted2(net, measure = degree)
targeted_score
targeted_score <- robustness.targeted2(targeted, measure = degree)
net
targeted_score <- robustness.targeted2(net, measure = degree)
targeted_score
random_score <- robustness.random2(net, measure = degree)
random_score
ggplot(targeted, aes(x=q, y=S, color=S)) + geom_point(alpha=.4, size=2) +
theme_bw() +
theme(plot.background = element_blank(),  panel.grid.minor = element_blank(),plot.title=element_text(size=15)) +
geom_line() +
ggtitle("Ataque secuencial dirigido") +
ylab("S(q)") +
xlab("q")
ggplot(random, aes(x=q, y=S, color=S)) + geom_point(alpha=.4, size=2) +
theme_bw() +
theme(plot.background = element_blank(),  panel.grid.minor = element_blank(),plot.title=element_text(size=15)) +
geom_line() +
ggtitle("Ataque secuencial aleatorio") +
ylab("S(q)") +
xlab("q")
library(igraph)
library(igraph)
nodes<-read.csv("string_node_degrees.tsv",sep ="")
links<-read.csv("string_interactions.tsv",sep="")
net <- graph_from_data_frame(d=links,vertices=nodes, directed=T)
nodes_prop<-read.csv("string_node_degrees_prop.tsv",sep ="")
links_prop<-read.csv("string_interactions_prop.tsv",sep="")
net_prop <- graph_from_data_frame(d=links_prop,vertices=nodes_prop, directed=T)
net_degree <- degree(net_prop, mode = c("out"))
table(net_degree)
hist(net_degree)
hist(net_degree, breaks = 30)
hist(net_degree, breaks = 45)
hist(net_degree, breaks = 45)
table(net_degree)
V(net)$size<-V(net)$node_degree
plot(net,layout=layout_nicely, edge.arrow.size=0.2, edge.curved=0.1, vertex.frame.color="black",vertex.label=V(net)$id, vertex.label.color="black", vertex.label.cex=0.7)
#
which.max(net_degree)
(net_degree)
(net_degree[38])
table
table(net_degree)
#
net_degree[which.max(net_degree)]
(net_degree)
hist(net_degree, breaks = 40)
hist(net_degree, breaks = 30)
hist(net_degree, breaks = 1)
hist(net_degree, breaks = 15)
hist(net_degree, breaks = 45)
hist(net_degree, breaks = 30)
hist(net_degree, breaks = 45)
hist(net_degree, breaks = 20)
net_betweenness <- betweenness(net_prop, directed = TRUE)
plot(net_prop,
vertex.label = NA,
edge.color = 'black',
vertex.size = sqrt(net_betweenness)+1,
edge.arrow.size = 0.05,
layout = layout_nicely(g))
plot(net_prop,
vertex.label = NA,
edge.color = 'black',
vertex.size = sqrt(net_betweenness)+1,
edge.arrow.size = 0.05,
layout = layout_nicely(net_prop))
plot(net_prop,
vertex.label = NA,
edge.color = 'black',
vertex.size = sqrt(net_betweenness)+1,
edge.arrow.size = 0.05,
layout = layout_nicely(net_prop))
plot(net_prop,
vertex.label = NA,
edge.color = 'black',
vertex.size = sqrt(net_betweenness)+1,
edge.arrow.size = 0.05,
layout = layout_nicely(net_prop))
plot(net_prop,
vertex.label = NA,
edge.color = 'black',
vertex.size = sqrt(net_betweenness)+1,
edge.arrow.size = 0.05,
layout = layout_nicely(net_prop))
plot(net_prop,
vertex.label = NA,
edge.color = 'black',
vertex.size = sqrt(net_betweenness)+1,
edge.arrow.size = 0.05,
layout = layout_nicely(net_prop))
plot(net_prop,
vertex.label = NA,
edge.color = 'black',
vertex.size = sqrt(net_betweenness)+1,
edge.arrow.size = 0.05,
layout = layout_nicely(net_prop))
plot(net_prop,
vertex.label = NA,
edge.color = 'black',
vertex.size = sqrt(net_betweenness)+1,
edge.arrow.size = 0.05,
layout = layout_nicely(net_prop))
plot(net_prop,
vertex.label = NA,
edge.color = 'black',
vertex.size = sqrt(net_betweenness)+1,
edge.arrow.size = 0.05,
layout = layout_nicely(net_prop))
#plot en el que el tama単o del nodo lo determina el numero de conexiones
plot(net_prop,
vertex.label = NA,
edge.color = 'black',
vertex.size = sqrt(net_betweenness),
edge.arrow.size = 0.05,
layout = layout_nicely(net_prop))
#plot en el que el tama単o del nodo lo determina el numero de conexiones
plot(net_prop,
vertex.label = NA,
edge.color = 'black',
vertex.size = sqrt(net_betweenness)-1,
edge.arrow.size = 0.05,
layout = layout_nicely(net_prop))
#plot en el que el tama単o del nodo lo determina el numero de conexiones
plot(net_prop,
vertex.label = NA,
edge.color = 'black',
vertex.size = sqrt(net_betweenness)-0.05,
edge.arrow.size = 0.05,
layout = layout_nicely(net_prop))
#plot en el que el tama単o del nodo lo determina el numero de conexiones
plot(net_prop,
vertex.label = NA,
edge.color = 'black',
vertex.size = sqrt(net_betweenness),
edge.arrow.size = 0.05,
layout = layout_nicely(net_prop))
# definimos las funciones:
# ataque dirigido:
sequential.attacks.targeted <- function(grafo, measure=degree){
q = seq(from=0,to=1,by=0.01)
g = grafo
S = max(components(grafo)$csize)/vcount(grafo)
contador = S
removalset = NULL
v = vcount(grafo)
s = max(components(grafo)$csize)
for(i in q){
if(max(components(g)$csize)/vcount(grafo) >0.05){
removalset <- names(sort(degree(g),decreasing = T)[1:(i*vcount(g))])
g <- delete.vertices(graph = g, v = removalset)
S = c(S, max(components(g)$csize)/vcount(grafo))
v <- c(v, vcount(g))
s = c(s, max(components(g)$csize))
contador = max(components(g)$csize)/vcount(grafo)
}
}
S.vs.q <- tbl_df(data.frame(cbind(q[1:length(S)],S,s,v)))
names(S.vs.q) <- c("q", "S", "s", "v")
return(S.vs.q)
}
# ataque aleatorio
sequential.attacks.random <- function(grafo, measure=degree){
q = seq(from=0,to=1,by=0.01)
g = grafo
S = max(components(grafo)$csize)/vcount(grafo)
contador = S
removalset = NULL
v = vcount(grafo)
s = max(components(grafo)$csize)
for(i in q){
if(contador > 0.05 & length(removalset) < vcount(g)/2){
removalset <- sample(x = V(g)$name, size = 1, replace = F)
g <- delete.vertices(graph = g, v = removalset)
S = c(S, max(components(g)$csize)/vcount(grafo))
v <- c(v, vcount(g))
s = c(s, max(components(g)$csize))
contador = max(components(g)$csize)/vcount(grafo)
}
}
S.vs.q <- tbl_df(data.frame(cbind(q[1:length(S)],S,s,v)))
names(S.vs.q) <- c("q", "S", "s", "v")
return(S.vs.q)
}
#puntuacion robustez dirigido
robustness.targeted2 <- function(grafo, measure=degree){
q = seq(from=0.01,to=1,by=0.01)
g = grafo
S = max(components(grafo)$csize)/vcount(grafo)
contador = S
removalset = NULL
for(i in q){
if(max(components(g)$csize)/vcount(grafo) >0.05){
removalset <- names(sort(degree(g),decreasing = T)[1:(i*vcount(g))])
g <- delete.vertices(graph = g, v = removalset)
S = c(S, max(components(g)$csize)/vcount(grafo))
contador = max(components(g)$csize)/vcount(grafo)
}
}
x <- as.numeric(q[1:length(S)])
y <- as.numeric(S)
id <- order(x)
return(sum(diff(x[id])*rollmean(y[id],2)))
}
#puntuacionrobustez aleatorio
robustness.random2 <- function(grafo, measure=degree){
q = seq(from=0.01,to=1,by=0.01)
g = grafo
S = max(components(grafo)$csize)/vcount(grafo)
contador = S
removalset = NULL
for(i in q){
if(contador > 0.05 & length(removalset) < vcount(g)/2){
removalset <- sample(x = V(g)$name, size = 10, replace = F)
g <- delete.vertices(graph = g, v = removalset)
S = c(S, max(components(g)$csize)/vcount(grafo))
contador = max(components(g)$csize)/vcount(grafo)
}
}
x <- as.numeric(q[1:length(S)])
x <- x[!is.na(x)]
y <- as.numeric(S)
id <- order(x)
return(sum(diff(x[id])*rollmean(y[id],2)))
}
# plot the graph
plot_graph <- function(graph){
V(graph)$label <- NA
V(graph)$name <- NA
V(graph)$size <- degree(graph)/5
E(graph)$edge.color <- "gray80"
V(graph)$color <- "tomato"
# graph_attr(graph, "layout") <- layout_with_lgl
graph_attr(graph, "layout") <- layout.kamada.kawai
plot(graph)
}
# plot
plot_graph <- function(graph){
V(graph)$label <- NA
V(graph)$name <- NA
V(graph)$size <- degree(graph)/5
E(graph)$edge.color <- "gray80"
V(graph)$color <- "tomato"
# graph_attr(graph, "layout") <- layout_with_lgl
graph_attr(graph, "layout") <- layout.kamada.kawai
plot(graph)
}
targeted <- sequential.attacks.targeted(net_prop, measure = degree)
# definimos las funciones:
# ataque dirigido:
sequential.attacks.targeted <- function(grafo, measure=degree){
q = seq(from=0,to=1,by=0.01)
g = grafo
S = max(components(grafo)$csize)/vcount(grafo)
contador = S
removalset = NULL
v = vcount(grafo)
s = max(components(grafo)$csize)
for(i in q){
if(max(components(g)$csize)/vcount(grafo) >0.05){
removalset <- names(sort(degree(g),decreasing = T)[1:(i*vcount(g))])
g <- delete.vertices(graph = g, v = removalset)
S = c(S, max(components(g)$csize)/vcount(grafo))
v <- c(v, vcount(g))
s = c(s, max(components(g)$csize))
contador = max(components(g)$csize)/vcount(grafo)
}
}
S.vs.q <- tbl_df(data.frame(cbind(q[1:length(S)],S,s,v)))
names(S.vs.q) <- c("q", "S", "s", "v")
return(S.vs.q)
}
# ataque aleatorio
sequential.attacks.random <- function(grafo, measure=degree){
q = seq(from=0,to=1,by=0.01)
g = grafo
S = max(components(grafo)$csize)/vcount(grafo)
contador = S
removalset = NULL
v = vcount(grafo)
s = max(components(grafo)$csize)
for(i in q){
if(contador > 0.05 & length(removalset) < vcount(g)/2){
removalset <- sample(x = V(g)$name, size = 1, replace = F)
g <- delete.vertices(graph = g, v = removalset)
S = c(S, max(components(g)$csize)/vcount(grafo))
v <- c(v, vcount(g))
s = c(s, max(components(g)$csize))
contador = max(components(g)$csize)/vcount(grafo)
}
}
S.vs.q <- tbl_df(data.frame(cbind(q[1:length(S)],S,s,v)))
names(S.vs.q) <- c("q", "S", "s", "v")
return(S.vs.q)
}
#puntuacion robustez dirigido
robustness.targeted2 <- function(grafo, measure=degree){
q = seq(from=0.01,to=1,by=0.01)
g = grafo
S = max(components(grafo)$csize)/vcount(grafo)
contador = S
removalset = NULL
for(i in q){
if(max(components(g)$csize)/vcount(grafo) >0.05){
removalset <- names(sort(degree(g),decreasing = T)[1:(i*vcount(g))])
g <- delete.vertices(graph = g, v = removalset)
S = c(S, max(components(g)$csize)/vcount(grafo))
contador = max(components(g)$csize)/vcount(grafo)
}
}
x <- as.numeric(q[1:length(S)])
y <- as.numeric(S)
id <- order(x)
return(sum(diff(x[id])*rollmean(y[id],2)))
}
#puntuacionrobustez aleatorio
robustness.random2 <- function(grafo, measure=degree){
q = seq(from=0.01,to=1,by=0.01)
g = grafo
S = max(components(grafo)$csize)/vcount(grafo)
contador = S
removalset = NULL
for(i in q){
if(contador > 0.05 & length(removalset) < vcount(g)/2){
removalset <- sample(x = V(g)$name, size = 10, replace = F)
g <- delete.vertices(graph = g, v = removalset)
S = c(S, max(components(g)$csize)/vcount(grafo))
contador = max(components(g)$csize)/vcount(grafo)
}
}
x <- as.numeric(q[1:length(S)])
x <- x[!is.na(x)]
y <- as.numeric(S)
id <- order(x)
return(sum(diff(x[id])*rollmean(y[id],2)))
}
# plot the graph
plot_graph <- function(graph){
V(graph)$label <- NA
V(graph)$name <- NA
V(graph)$size <- degree(graph)/5
E(graph)$edge.color <- "gray80"
V(graph)$color <- "tomato"
# graph_attr(graph, "layout") <- layout_with_lgl
graph_attr(graph, "layout") <- layout.kamada.kawai
plot(graph)
}
# plot
plot_graph <- function(graph){
V(graph)$label <- NA
V(graph)$name <- NA
V(graph)$size <- degree(graph)/5
E(graph)$edge.color <- "gray80"
V(graph)$color <- "tomato"
# graph_attr(graph, "layout") <- layout_with_lgl
graph_attr(graph, "layout") <- layout.kamada.kawai
plot(graph)
}
library(dplyr)
library(igraph)
library(ggplot2)
library(zoo)
targeted <- sequential.attacks.targeted(net_prop, measure = degree)
targeted$attack <- rep("targeted")
ggplot(targeted, aes(x=q, y=S, color=S)) + geom_point(alpha=.4, size=2) +
theme_bw() +
theme(plot.background = element_blank(),  panel.grid.minor = element_blank(),plot.title=element_text(size=15)) +
geom_line() +
ggtitle("Ataque secuencial dirigido") +
ylab("S(q)") +
xlab("q")
targeted_score <- robustness.targeted2(net_prop, measure = degree)
targeted_score
random <- sequential.attacks.random(net_prop, measure = degree)
random$attack <- rep("random")
ggplot(random, aes(x=q, y=S, color=S)) + geom_point(alpha=.4, size=2) +
theme_bw() +
theme(plot.background = element_blank(),  panel.grid.minor = element_blank(),plot.title=element_text(size=15)) +
geom_line() +
ggtitle("Ataque secuencial aleatorio") +
ylab("S(q)") +
xlab("q")
targeted_score
targeted
targeted[targeted$q == 0.1]
targeted[targeted$q.value() == 0.1]
targeted[targeted$q == 0.1]
targeted
targeted[targeted$q == '0.1']
targeted[targeted$q.equals(0.1)]
targeted[targeted$q == '0.1', ]
targeted
# Identify key nodes using eigenvector centrality
g.ec <- eigen_centrality(net_prop)
which.max(g.ec$vector)
# Identify key nodes using eigenvector centrality
g.ec <- eigen_centrality(net_prop)
which.max(g.ec$vector)
## FORREST
##      36
# Plot Forrest Gump Network
plot(net_prop,
vertex.label.color = "black",
vertex.label.cex = 0.6,
vertex.size = 25*(g.ec$vector),
edge.color = 'gray88',
main = "Forrest Gump Network"
)
gd <- edge_density(net_prop)
# Get the diameter of the graph g
diameter(net_prop, directed = TRUE)
# Get the average path length of the graph g
g.apl <- mean_distance(net_prop, directed = FALSE)
g.apl
gd
# Get the average path length of the graph g
g.apl <- mean_distance(net_prop, directed = FALSE)
g.apl
kc = fastgreedy.community(net_prop)
kc = fastgreedy.community(net)
library(threejs)
install.packages('threejs')
library(threejs)
###
# Set a vertex attribute called 'color' to 'dodgerblue'
g <- set_vertex_attr(net_prop, "color", value = "dodgerblue")
# Redraw the graph and make the vertex size 1
graphjs(g, vertex.size = 1)
#ataque dirigido con otra funcion
robustness(net_prop, type = c("vertex", "edge"), measure = c("btwn.cent",
"degree", "random"), N = 1000)
install.packages('braingraph')
s
y
yes
install.packages('brainGraph')
library(brainGraph)
#ataque dirigido con otra funcion
robustness(net_prop, type = c("vertex", "edge"), measure = c("btwn.cent",
"degree", "random"), N = 1000)
library(brainGraph)
#ataque dirigido con otra funcion
robustness(net_prop, type = c("vertex", "edge"), measure = c("btwn.cent",
"degree", "random"), N = 10)
#ataque dirigido con otra funcion
robustness(net_prop, type = c("vertex", "edge"), measure = c("btwn.cent",
"degree", "random"), N = 1000)
library(brainGraph)
#ataque dirigido con otra funcion
robustness(net_prop, type = c("vertex", "edge"), measure = 'degree' , N = 1000)
#ataque dirigido con otra funcion
robustness(net_prop, type = "vertex", measure = 'degree' , N = 1000)
plot(net_prop, vertex.label.color = "black", layout = m1 )
m1 <- layout_nicely(net_prop)
plot(net_prop, vertex.label.color = "black", layout = m1 )
plot(net, vertex.label.color = "black", layout = m1 )
_prop
m1 <- layout_nicely(net_prop)
plot(net_prop, vertex.label.color = "black", layout = m1 )
