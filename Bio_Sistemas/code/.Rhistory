library(DOSE)
library(igraph)
path<-"~/Biologia_de_Sistemas/Bio_Sistemas/code/" #select your path
setwd(path)
library(igraph)
nodes<-read.csv("string_node_degrees.tsv",sep ="")
links<-read.csv("string_interactions.tsv",sep="")
net <- graph_from_data_frame(d=links,vertices=nodes, directed=T)
getwd()
library(igraph)
nodes<-read.csv("~/Biologia_de_Sistemas/Bio_Sistemas/code/string_node_degrees.tsv",sep ="")
path<-"~/Biologia_de_Sistemas/Bio_Sistemas/code/" #select your path
setwd(path)
library(igraph)
nodes<-read.csv("string_node_degrees.tsv",sep ="")
links<-read.csv("string_interactions.tsv",sep="")
net <- graph_from_data_frame(d=links,vertices=nodes, directed=T)
library(dplyr)
library(ggplot2)
# definimos las funciones:
# ataque dirigido:
sequential.attacks.targeted <- function(grafo, measure=degree){
q = seq(from=0,to=1,by=0.01)
g = grafo
S = max(components(grafo)$csize)/vcount(grafo)
contador = S
removalset = NULL
v = vcount(grafo)
s = max(components(grafo)$csize)
for(i in q){
if(max(components(g)$csize)/vcount(grafo) >0.05){
removalset <- names(sort(degree(g),decreasing = T)[1:(i*vcount(g))])
g <- delete.vertices(graph = g, v = removalset)
S = c(S, max(components(g)$csize)/vcount(grafo))
v <- c(v, vcount(g))
s = c(s, max(components(g)$csize))
contador = max(components(g)$csize)/vcount(grafo)
}
}
S.vs.q <- tbl_df(data.frame(cbind(q[1:length(S)],S,s,v)))
names(S.vs.q) <- c("q", "S", "s", "v")
return(S.vs.q)
}
# ataque aleatorio
sequential.attacks.random <- function(grafo, measure=degree){
q = seq(from=0,to=1,by=0.01)
g = grafo
S = max(components(grafo)$csize)/vcount(grafo)
contador = S
removalset = NULL
v = vcount(grafo)
s = max(components(grafo)$csize)
for(i in q){
if(contador > 0.05 & length(removalset) < vcount(g)/2){
removalset <- sample(x = V(g)$name, size = 10, replace = F)
g <- delete.vertices(graph = g, v = removalset)
S = c(S, max(components(g)$csize)/vcount(grafo))
v <- c(v, vcount(g))
s = c(s, max(components(g)$csize))
contador = max(components(g)$csize)/vcount(grafo)
}
}
S.vs.q <- tbl_df(data.frame(cbind(q[1:length(S)],S,s,v)))
names(S.vs.q) <- c("q", "S", "s", "v")
return(S.vs.q)
}
# plot
plot_graph <- function(graph){
V(graph)$label <- NA
V(graph)$name <- NA
V(graph)$size <- degree(graph)/5
E(graph)$edge.color <- "gray80"
V(graph)$color <- "tomato"
# graph_attr(graph, "layout") <- layout_with_lgl
graph_attr(graph, "layout") <- layout.kamada.kawai
plot(graph)
}
targeted <- sequential.attacks.targeted(net, measure = degree)
targeted$attack <- rep("targeted")
ggplot(targeted, aes(x=q, y=S, color=S)) + geom_point(alpha=.4, size=2) +
theme_bw() +
theme(plot.background = element_blank(),  panel.grid.minor = element_blank(),plot.title=element_text(size=15)) +
geom_line() +
ggtitle("Targeted sequential attacks") +
ylab("S(q)") +
xlab("q")
random <- sequential.attacks.random(net, measure = degree)
random$attack <- rep("random")
ggplot(random, aes(x=q, y=S, color=S)) + geom_point(alpha=.4, size=2) +
theme_bw() +
theme(plot.background = element_blank(),  panel.grid.minor = element_blank(),plot.title=element_text(size=15)) +
geom_line() +
ggtitle("Random sequential attacks") +
ylab("S(q)") +
xlab("q")
ggplot(random)
plot_graph(random)
random
random
targeted
random <- sequential.attacks.random(net, measure = degree)
random$attack <- rep("random")
ggplot(random, aes(x=q, y=S, color=S)) + geom_point(alpha=.4, size=2) +
theme_bw() +
theme(plot.background = element_blank(),  panel.grid.minor = element_blank(),plot.title=element_text(size=15)) +
geom_line() +
ggtitle("Random sequential attacks") +
ylab("S(q)") +
xlab("q")
robustness.targeted2 <- function(grafo, measure=degree){
# Computes the size of the largest cluster as we remove vertices from high degree to low degree (relative to the original grafo)
# Implements the robustness described in Schneider, C. M. & Moreira, A. A. Mitigation of malicious attacks on networks. in (2011). doi:10.1073/pnas.1009440108/-/DCSupplemental
#update the degree distribution after each node removal step
# Returns the robustness of the network R = 1/No âˆ‘S(q)
# Area under the curve:
# x <- set of values
# y <- set ov values y(x)
# id <- order(x)
#
# AUC <- sum(diff(x[id])*rollmean(y[id],2))
q = seq(from=0.01,to=1,by=0.01)
g = grafo
S = max(components(grafo)$csize)/vcount(grafo)
contador = S
removalset = NULL
for(i in q){
if(max(components(g)$csize)/vcount(grafo) >0.05){
removalset <- names(sort(degree(g),decreasing = T)[1:(i*vcount(g))])
g <- delete.vertices(graph = g, v = removalset)
S = c(S, max(components(g)$csize)/vcount(grafo))
contador = max(components(g)$csize)/vcount(grafo)
}
}
x <- as.numeric(q[1:length(S)])
y <- as.numeric(S)
id <- order(x)
return(sum(diff(x[id])*rollmean(y[id],2)))
}
targeted2 <- robustness.targeted2(net, measure = degree)
robustness.targeted2 <- function(grafo, measure=degree){
q = seq(from=0.01,to=1,by=0.01)
g = grafo
S = max(components(grafo)$csize)/vcount(grafo)
contador = S
removalset = NULL
for(i in q){
if(max(components(g)$csize)/vcount(grafo) >0.05){
removalset <- names(sort(degree(g),decreasing = T)[1:(i*vcount(g))])
g <- delete.vertices(graph = g, v = removalset)
S = c(S, max(components(g)$csize)/vcount(grafo))
contador = max(components(g)$csize)/vcount(grafo)
}
}
x <- as.numeric(q[1:length(S)])
y <- as.numeric(S)
id <- order(x)
return(sum(diff(x[id])*rollmean(y[id],2)))
}
targeted2 <- robustness.targeted2(net, measure = degree)
library(zoo)
targeted2 <- robustness.targeted2(net, measure = degree)
targeted2$attack <- rep("targeted")
ggplot(targeted2, aes(x=q, y=S, color=S)) + geom_point(alpha=.4, size=2) +
theme_bw() +
theme(plot.background = element_blank(),  panel.grid.minor = element_blank(),plot.title=element_text(size=15)) +
geom_line() +
ggtitle("Targeted sequential attacks") +
ylab("S(q)") +
xlab("q")
targeted2
targeted2 <- robustness.targeted2(net, measure = degree)
targeted2
# definimos las funciones:
# ataque dirigido:
sequential.attacks.targeted <- function(grafo, measure=degree){
q = seq(from=0,to=1,by=0.01)
g = grafo
S = max(components(grafo)$csize)/vcount(grafo)
contador = S
removalset = NULL
v = vcount(grafo)
s = max(components(grafo)$csize)
for(i in q){
if(max(components(g)$csize)/vcount(grafo) >0.05){
removalset <- names(sort(degree(g),decreasing = T)[1:(i*vcount(g))])
g <- delete.vertices(graph = g, v = removalset)
S = c(S, max(components(g)$csize)/vcount(grafo))
v <- c(v, vcount(g))
s = c(s, max(components(g)$csize))
contador = max(components(g)$csize)/vcount(grafo)
}
}
S.vs.q <- tbl_df(data.frame(cbind(q[1:length(S)],S,s,v)))
names(S.vs.q) <- c("q", "S", "s", "v")
return(S.vs.q)
}
# ataque aleatorio
sequential.attacks.random <- function(grafo, measure=degree){
q = seq(from=0,to=1,by=0.01)
g = grafo
S = max(components(grafo)$csize)/vcount(grafo)
contador = S
removalset = NULL
v = vcount(grafo)
s = max(components(grafo)$csize)
for(i in q){
if(contador > 0.05 & length(removalset) < vcount(g)/2){
removalset <- sample(x = V(g)$name, size = 10, replace = F)
g <- delete.vertices(graph = g, v = removalset)
S = c(S, max(components(g)$csize)/vcount(grafo))
v <- c(v, vcount(g))
s = c(s, max(components(g)$csize))
contador = max(components(g)$csize)/vcount(grafo)
}
}
S.vs.q <- tbl_df(data.frame(cbind(q[1:length(S)],S,s,v)))
names(S.vs.q) <- c("q", "S", "s", "v")
return(S.vs.q)
}
#puntuacion robustez dirigido
robustness.targeted2 <- function(grafo, measure=degree){
q = seq(from=0.01,to=1,by=0.01)
g = grafo
S = max(components(grafo)$csize)/vcount(grafo)
contador = S
removalset = NULL
for(i in q){
if(max(components(g)$csize)/vcount(grafo) >0.05){
removalset <- names(sort(degree(g),decreasing = T)[1:(i*vcount(g))])
g <- delete.vertices(graph = g, v = removalset)
S = c(S, max(components(g)$csize)/vcount(grafo))
contador = max(components(g)$csize)/vcount(grafo)
}
}
x <- as.numeric(q[1:length(S)])
y <- as.numeric(S)
id <- order(x)
return(sum(diff(x[id])*rollmean(y[id],2)))
}
#puntuacionrobustez aleatorio
robustness.random2 <- function(grafo, measure=degree){
q = seq(from=0.01,to=1,by=0.01)
g = grafo
S = max(components(grafo)$csize)/vcount(grafo)
contador = S
removalset = NULL
for(i in q){
if(contador > 0.05 & length(removalset) < vcount(g)/2){
removalset <- sample(x = V(g)$name, size = 10, replace = F)
g <- delete.vertices(graph = g, v = removalset)
S = c(S, max(components(g)$csize)/vcount(grafo))
contador = max(components(g)$csize)/vcount(grafo)
}
}
x <- as.numeric(q[1:length(S)])
x <- x[!is.na(x)]
y <- as.numeric(S)
id <- order(x)
return(sum(diff(x[id])*rollmean(y[id],2)))
}
# plot the graph
plot_graph <- function(graph){
V(graph)$label <- NA
V(graph)$name <- NA
V(graph)$size <- degree(graph)/5
E(graph)$edge.color <- "gray80"
V(graph)$color <- "tomato"
# graph_attr(graph, "layout") <- layout_with_lgl
graph_attr(graph, "layout") <- layout.kamada.kawai
plot(graph)
}
# plot
plot_graph <- function(graph){
V(graph)$label <- NA
V(graph)$name <- NA
V(graph)$size <- degree(graph)/5
E(graph)$edge.color <- "gray80"
V(graph)$color <- "tomato"
# graph_attr(graph, "layout") <- layout_with_lgl
graph_attr(graph, "layout") <- layout.kamada.kawai
plot(graph)
}
targeted <- sequential.attacks.targeted(net, measure = degree)
targeted$attack <- rep("targeted")
ggplot(targeted, aes(x=q, y=S, color=S)) + geom_point(alpha=.4, size=2) +
theme_bw() +
theme(plot.background = element_blank(),  panel.grid.minor = element_blank(),plot.title=element_text(size=15)) +
geom_line() +
ggtitle("Targeted sequential attacks") +
ylab("S(q)") +
xlab("q")
targeted_score <- robustness.targeted2(net, measure = degree)
targeted_score
targeted_score <- robustness.targeted2(targeted, measure = degree)
net
targeted_score <- robustness.targeted2(net, measure = degree)
targeted_score
random_score <- robustness.random2(net, measure = degree)
random_score
ggplot(targeted, aes(x=q, y=S, color=S)) + geom_point(alpha=.4, size=2) +
theme_bw() +
theme(plot.background = element_blank(),  panel.grid.minor = element_blank(),plot.title=element_text(size=15)) +
geom_line() +
ggtitle("Ataque secuencial dirigido") +
ylab("S(q)") +
xlab("q")
ggplot(random, aes(x=q, y=S, color=S)) + geom_point(alpha=.4, size=2) +
theme_bw() +
theme(plot.background = element_blank(),  panel.grid.minor = element_blank(),plot.title=element_text(size=15)) +
geom_line() +
ggtitle("Ataque secuencial aleatorio") +
ylab("S(q)") +
xlab("q")
